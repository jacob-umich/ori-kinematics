\newpage
\section{Conclusion}
On the surface level, we made a library to perform kinematic simulations. However, the real goal we were trying to achieve was to practice making software close to the level that is done by professionals in scientific computing so that one day, we may make our own scientific computing software that is used by others in the industry. In this way, we believe we met our objective. However the following sections will go into detail on the specific objectives listed in the introduction, as well as things we learned and possible future improvements.
\subsection{Objectives}
Recalling the core objectives, we can discuss whether it was met or not
\begin{itemize}
    \item The library shall be able to simulate the kinematics any convex rigid body that can be sufficiently described by its vertices. \textbf{Almost}. As seen in Miura fold example, we were not able to get the expected motion, but we did however get the cube to work.
    \item The library shall make use of performant linear algebra libraries. \textbf{Mostly}. LAPACK and OpenBLAS were successfully implemented, although it would have been nice to add more performant libraries like PETSC.
    \item The library shall make use of Object-Oriented Design. \textbf{Yes}. The code makes strong use of OOP and all the relevant concepts like abstraction, classes, private/public members, etc. This allowed the code to be quite modular.
    \item The library shall make use of design patterns. \textbf{Yes}. The waterfall design pattern was employ and helped drive the code design.
    \item The library shall use a CMake based build system. \textbf{Yes}. CMake was successfully used and worked wonderfully with the code, making compilation on various environments very easy.
    \item The library shall use C++ mainly and C if needed. \textbf{Yes}. Almost all the code was in C++. We also implemented scripting languages which was a bonus.
    \item The library shall incorporate testing. \textbf{Yes}. Many different unit tests were incorporated and helped us find issues quickly. Verification tests also helped us find unexpected problems, although we could have had more verification tests but ran short on time.

\end{itemize}
\subsection{What was Learned and Value of Work}
A significant amount of learning came along with this project. Learning about C++ and OOP was an invaluable lesson, getting hands-on work and creating our own classes really helped us understand the benefits of OOP and the syntax of C++. Of course, we also learned a lot about kinematic simulations and the math behind it. Going through the weeds and figuring out how to program everything really strengthen our understanding of the numerical methods and linear algebra used to compute the admissible motions. A lot was learned about compilation and linking as well. Having to make the CMake files helped us understand how compilation works on Great Lakes and other environments, as well as the building process and required file structures. The testing also proved to be extremely valuable in debugging code \textit{before} we tried to run cases. It was surprising how many issues it caught beforehand. Finally, we learned a lot about working as a team and using GitHub for code management. Using GitHub helped us learn to to state our problems and update our work. The process of creating pull requests or merging code or creating branches was very valuable and will help us work with others in the future. We come out of this project with a good base for a more powerful origami kinematics library which is valuable to the members whose area of research is origami kinematics. However, what was the most valuable was the lessons learned and experienced gained developing this code and using different tools and methods of the scientific computing field.
\subsection{Areas of Future Work}
There are several areas of improvement for future work. The clearest direction is to implement more complicated origami, like the waterbomb pattern. As mentioned before, the biggest hurdle in this is creating the JSON file. More work should also be done to correct any potential mistakes and get the Miura pattern to work before going to more complicated problems, however. Another problem is to include more realsitic physics into the library. We can incorporate external forces that give preference to certain motions, or add friction and contact restraints. We can also do non-rigid bodies as a more complicated problem. We can also implement more powerful libraries, like PETSC. PETSC can be used to implement higher-order schemes like Runge-Kutta for solving the ODE. This would reduce the error between time steps and obtain a more realistic solution.

